@[TOC](目录)
# 前言
- 由于我手上没有扫描枪，测试盘点很不方便，于是我去搜索扫码枪的原理，发现就是`模拟键盘输入`。
- 于是我自己用python脚本实现模拟键盘输入。
# 模拟键盘输入
- 最开始我用`pydirectinput`，发现输入太慢，遂改为`pynput`。
## 代码
- 以下是完整代码。

```python
'''
模拟键盘输入
2025-10-28 15:16:00
Zhou Zhongqing

经过测试pynput 比较快
'''
# import pydirectinput
import time
# import pyautogui

from pynput.keyboard import Key, Controller
# import keyboard as kb

import sys
import getopt


def pynput_input(sleep, str: str):  # 执行时间0.007
    if sleep > 0:
        time.sleep(sleep)
    keyboard = Controller()

    str_array: [str] = list(str)
    for key in str_array:
        keyboard.press(key)
        time.sleep(0.01)

    keyboard.press(Key.enter)


# def keyboard_input():  # 执行时间 0.183
#     time.sleep(3)
#     sn = [1, 1, 2, 0, 5, 2, 3, 2]
#     for key in sn:
#         kb.press_and_release(str(key))


def help():
    print('''
    -t --time time second, optional
    -s --str send str,must
    ''')


if __name__ == '__main__':
    # longopts 表示识别--help, --host=xx, --port=1234的长选项
    opts, args = getopt.getopt(sys.argv[1:], "t:s:", ["help", "time=", "str="])

    sleep_time = 0
    send_str = None

    if opts is None or len(opts) < 1:
        help()

    for opt, arg in opts:
        if opt in ("-help", "--help"):
            help()
        elif opt in ("-t", "--time"):
            sleep_time = int(arg)
        elif opt in ("-s", "--str"):
            send_str = arg
        else:
            help()

    if send_str:
        start_time = time.time()
        pynput_input(sleep_time, send_str)
        end_time = time.time()
        diff_time = (end_time - start_time) * 1000
        print(f"执行时间{diff_time}毫秒")

```
## 运行效果
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/69d992a43f6f47d8a7891cc92135cfe4.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4db3492af4f14fb68dbcdb66bb445a0b.gif)




# 第二阶段
- 想着既然模拟输入已经完成，如果能把我手工输入转换为扫码，替代扫码枪也挺有意思的。
- 我的思路：
	- 我手上比较方便的扫码设备就是手机了。所以手机定为扫码设备。
	- 手机扫码后发送给服务端，服务端模拟键盘输入。

## 移动端
- 使用uniapp x编写，核心代码如下。

```html
 <template>
	<view class="container" :style="containerStyle">
		<view class="gateway_url_box">
			<input class="gateway_class" v-model="gateway" placeholder="请输入服务地址" />
			<!-- <button class="check_btn" @click="checkServer">检测</button> -->
		</view>

		<view class="qr_box">
			<camera class="qr_camera" flash="auto" :style="cameraStyle" :resolution="'high'" :mode="'scanCode'"
				@scancode="handleScanCode">
			</camera>
			<!-- <view class="camera-scan-code-back-wrap">
				<button type="default" @click="navigateBack">返回正常模式</button>
			</view> -->
			<view class="camera-scan-code-table">
				<!-- <view class="camera-scan-code-table-pair">
					<view class="camera-scan-code-table-pair-label">
						<text>类型</text>
					</view>
					<view class="camera-scan-code-table-pair-value">
						<text>{{ result?.type}}</text>
					</view>
				</view> -->

				<view class="camera-scan-code-table-pair camera-scan-code-table-top-line">
					<view class="camera-scan-code-table-pair-label">
						<text>结果</text>
					</view>
					<view class="camera-scan-code-table-pair-value">
						<text>{{ result.result }}</text>
					</view>
				</view>
			</view>
		</view>
	</view>
</template>

<script setup lang="uts">
	type CameraScanCodeResult = {
		type : string | null;
		result : string | null;
	}

	let result = ref<CameraScanCodeResult>({ type: null, result: ''})

	let containerStyle = 'top:' + uni.getSystemInfoSync().statusBarHeight + 'px';

	let cameraStyle = {
		'height': (uni.getSystemInfoSync().screenHeight - 350) + 'px'
	}

	// let gateway = ref<string>("http://192.168.")
	let gateway = ref<string>("http://192.168.39.166:8848")

	let scanQr = ref('')

	let innerAudio = uni.createInnerAudioContext()
	innerAudio!.src = '/static/ding.mp3'

	onReady(() => {
		console.log("onReady")
	})

	const checkServer = () => {
		console.log("检测服务器")
	}

	const playInnerMusic = () => {
		innerAudio!.play()
	}

	const sendData = (data : CameraScanCodeResult) => {
		
		uni.request({
			url: gateway.value + "/mock_input?sn=" + data.result,
			method: "GET",
			timeout: 6000,
			sslVerify: false,
			withCredentials: false,
			firstIpv4: false,
			success: (res) => {
				console.log("res " , res)
			},
			fail: (res) => {
				uni.showToast({
					icon: "error",
					title:'发送数据失败，请检测服务器地址'
				})
			},
		});
	}

	const handleScanCode = (ev : UniCameraScanCodeEvent) => {
		const deatil = ev.detail;
		result.value = {
			type: deatil.type,
			result: deatil.result
		}
		playInnerMusic()

		sendData({
			type: deatil.type,
			result: deatil.result
		} as CameraScanCodeResult)
	}
</script>

<style lang="scss">
	.container {
		width: 750rpx;
		height: 100%;
		display: flex;
		flex-direction: column;
		position: relative;

		.gateway_url_box {
			display: flex;
			flex-direction: row;
			position: relative;
			justify-content: center;
			margin-top: 50rpx;
			height: 100rpx;

			.gateway_class {
				width: 450rpx;
				height: 100rpx;
				border: 1rpx solid #42b983;
				border-radius: 5rpx;

			}

			.check_btn {
				width: 150rpx;
			}
		}

		.qr_box {
			// border: 1px solid red;
			display: flex;
			flex-direction: column;
			justify-content: center;
			position: relative;
			top: 50rpx;

			.qr_camera {
				width: 750rpx;
				// height: 800rpx;
			}
		}



		.camera-scan-code-back-wrap {
			display: flex;
			justify-content: center;
			align-items: center;
		}

		.camera-scan-code-table {
			background-color: white;
			margin-top: 20px;
		}

		.camera-scan-code-table-pair {
			height: 50px;
			flex-direction: row;
			justify-content: space-between;
			align-items: center;
		}

		.camera-scan-code-table-pair-label {
			flex-grow: 1;
			margin-left: 15px;

		}

		.camera-scan-code-table-pair-value {
			flex-grow: 2;

		}

		.camera-scan-code-table-top-line {
			border-top: 1px solid #eee;
		}



	}
</style>
```


## 服务端代码
- 因为我想打包成exe,希望包更精简，所以使用python自带的socket实现接受HTTP请求，代码如下：

```python
'''
扫码助手
Zhou Zhongqing
2025-10-29 21:30:00
'''

# 导入必要的模块
import socket
import time
from pynput.keyboard import Key, Controller

keyboard = Controller()

#  参考 https://segmentfault.com/a/1190000044701510
# 定义一个简单的HTTP服务器类
class SimpleHTTPServer:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.server_socket = None

    def start(self):
        try:
            # 创建一个TCP套接字
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # 设置套接字选项，允许地址重用
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            # 绑定主机和端口
            self.server_socket.bind((self.host, self.port))
            # 监听连接
            self.server_socket.listen(5)
            print("HTTP 服务器已启动，监听地址：%s，端口：%d" % (self.host, self.port))

            while True:
                # 接受连接
                client_socket, client_address = self.server_socket.accept()
                print("接收到来自 %s 的连接" % str(client_address))
                # 处理HTTP请求
                self.handle_request(client_socket)

        except Exception as e:
            print("`发生异常：%s" % str(e))

        finally:
            if self.server_socket:
                self.server_socket.close()
                print("HTTP 服务器已关闭")

    def handle_request(self, client_socket):
        # 接收客户端请求数据
        request_data = client_socket.recv(1024).decode('utf-8')
        # 解析请求
        request_lines = request_data.split('\n')
        if request_lines:
            # 获取请求方法、路径和HTTP版本
            method, path, http_version = request_lines[0].strip().split()
            # print("请求方法：%s，路径：%s，HTTP版本：%s" % (method, path, http_version))
            response_body = ""
            if path.find('/mock_input') >= 0:
                parameter = resolve_parameter(path)
                handler_mock_input(parameter)
                # 构造HTTP响应
                response_body = response_body_format()

            response_headers = [
                "HTTP/1.1 200 OK",
                "Content-Type: text/html",
                "Content-Length: %d" % len(response_body),
                "\n"
            ]
            response = '\n'.join(response_headers) + response_body

            # 发送响应数据到客户端
            client_socket.sendall(response.encode('utf-8'))
            # 关闭客户端连接
            client_socket.close()
            # print("响应已发送")


def handler_mock_input(parameter:dict[str,str]) -> None:
    sn = parameter['sn']
    print("sn ",sn)
    pynput_input(sn)



def resolve_parameter(path: str) -> dict[str, str]:
    parameter = path.split('?')[1]
    # print("参数：%s" % parameter)

    params = parameter.split("&")
    dict_param:dict[str,str] = {}
    for param in params:
        param_array = param.split('=')
        dict_param[param_array[0]] = param_array[1]
        # print("参数名：%s，参数值：%" % (param.split('=')[0], param.split('=')[1]))
    return dict_param


def response_body_format():
    return '{"code":200,"data":"ok"}'



def pynput_input(str: str):

    str_array: [str] = list(str)
    for key in str_array:
        keyboard.press(key)
        time.sleep(0.001)

    keyboard.press(Key.enter)
# 主函数
if __name__ == "__main__":
    # 服务器主机和端口
    HOST = '0.0.0.0'
    PORT = 8848
    # 创建HTTP服务器实例并启动
    http_server = SimpleHTTPServer(HOST, PORT)
    http_server.start()


```


## 运行效果

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/41f57213df024ed1b002031424a2c94f.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f441a0f5a28241b79dee297632447c86.jpeg)


# 本文源码地址

- [https://github.com/1030907690/scan_qr_assistant](https://github.com/1030907690/scan_qr_assistant)
- [https://github.com/1030907690/public-script/blob/master/generic/mock_keyboard.py](https://github.com/1030907690/public-script/blob/master/generic/mock_keyboard.py)
- [https://github.com/1030907690/public-script/blob/master/generic/scan_qr_assistant.py](https://github.com/1030907690/public-script/blob/master/generic/scan_qr_assistant.py)

# 参考
- [https://juejin.cn/post/7083669827965059079](https://juejin.cn/post/7083669827965059079)
- [https://segmentfault.com/a/1190000044701510](https://segmentfault.com/a/1190000044701510)