---
layout:					post
title:					"《架构设计2.0大型分布式系统架构方法论与实践》三高笔记"
author:					Zhou Zhongqing
header-style:				text
catalog:					true
tags:
		- Web
		- JavaScript
---
@[TOC](目录)
## 前言
- 因为本人没多少`三高`的实战经验，所以对《架构设计2.0大型分布式系统架构方法论与实践》这本书的`三高`比较感兴趣，在此做个记录，并加入一点自己的理解（如果有错误的地方请批评指出，感激不尽）。
- 何为`三高`？
	- `高并发`：高并发是为了让系统变得更有效率。
	- `高可靠`：为了让系统变得更靠谱，尽可能减少故障发生次数。
	- `高可用`：为了故障发生后，故障恢复时间尽可能的短。

## 高并发
- `高并发`：高并发是为了让系统变得更有效率。高并发又可以分为几种侧重类型：`高并发读`、`高并发写`、`高并发读写`。

### 高并发读
#### 动静分离与CDN加速
- 静态内容常用的处理策略就是`CDN`。


#### 缓存
- `本地缓存`或`集中式缓存（如Redis/Memcached）`。
#### 并发读与Pipeline
- 并发读：串行改并行，可以使用`FutureTask`、`CompleteService`、`CompletableFuture`实现，`FutureTask`使用具体可参考拙作[使用FutureTask优化业务代码](https://blog.csdn.net/baidu_19473529/article/details/110878493)。

- Pipeline：多个Get操作一个个发出去，不等等返回结果，就像流入一个管道一样，结果从另一个管道流出。这块很像`HTTP Pipeline`。

#### 重写轻读

- 书中举例微博Feeds流，要查询用户Feeds流时，要先查询关注的用户列表，不利于高并发查询，所以为每个用户准备一个收件箱。某人发了条微博后，给粉丝的信箱都投递一条数据。这样把计算逻辑从“读”的一端移到了“写”的一端。
- 宽表：其实就是冗余字段。

#### 读写分离
- 例如MySQL可以做集群，`读写分离`，读的节点可以多一些。

#### 批量
- 可以参考拙作[高并发场景下请求合并(批量)](https://blog.csdn.net/baidu_19473529/article/details/124092081)。
### 高并发写
#### 数据分片
- 例如MySQL`分库分表`。


#### 任务分片
- 任务分片：例如把生产汽车的过程分成多道工序。虽然对每辆汽车来说依旧是串行的，但工序之间是并行的。对应代码与`FutureTask`的含义有所关联，`FutureTask`使用具体可参考拙作[使用FutureTask优化业务代码](https://blog.csdn.net/baidu_19473529/article/details/110878493)。

#### 异步化
- 书中举例短信验证码的例子：请求发送验证码加入到消息队列，由另一个程序消费。

#### 批量
- 书中提到了广告计费系统的合并扣费，把用户分组，多个扣款的请求合并成一个，也就是说只需要调用一次数据库，减少了数据库压力，也提高了执行效率。虽然这是高并发写，但同样可以参考拙作[高并发场景下请求合并(批量)](https://blog.csdn.net/baidu_19473529/article/details/124092081)。

## 高可靠
- `高可靠`：为了让系统变得更靠谱，尽可能减少故障发生次数。总结下面7个有效措施。
### 七板斧
- 1、限流
- 2、降级
- 3、熔断
- 4、超时与重试
- 5、隔离
- 6、灰度发布、滚动发布、备份、回滚
- 7、监控体系和日志报警



## 高可用
- `高可用`：为了故障发生后，故障恢复时间尽可能的短。要想快速恢复，要避免单点。
### 高可用架构几个核心问题
- 故障探测。
- 脑裂问题。
- 数据一致性。
- 对客户端透明。
- 高可用依赖的连环套问题。


